# -*- coding: utf-8 -*-
"""
Fit circles to superresolution rings in images demonstrating resolved
images of two NVs separated by less than the diffraction limit.

Created on February 25, 2022

@author: mccambria
"""

# %% Imports


from calendar import c
from sqlite3 import paramstyle
import utils.tool_belt as tool_belt
import utils.common as common
import matplotlib.pyplot as plt
import numpy as np
from scipy.optimize import minimize, brute
from numpy import half, pi
from matplotlib.patches import Circle


# %% Constants

num_circle_samples = 100
phi_linspace = np.linspace(0, 2 * pi, num_circle_samples)


# %% Functions


def cost(params, image, debug):
    """
    Faux-integrate the pixel values around the circle. Then muliply by -1 so that
    lower values are better and we can use scipy.optimize.minimize.
    By faux-integrate I mean average the values under a 1000 point, linearly spaced
    sampling of the circle.
    """

    circle_center_x, circle_center_y, circle_radius = params

    # Use a double circle to account for the ring width
    half_width = 2
    radii = [circle_radius - half_width, circle_radius + half_width]
    integrand = 0
    num_valid_samples = 0
    image_domain = image.shape

    for radius in radii:

        circle_samples_x = circle_center_x + radius * np.cos(phi_linspace)
        circle_samples_y = circle_center_y + radius * np.sin(phi_linspace)
        circle_samples_x_round = [round(el) for el in circle_samples_x]
        circle_samples_y_round = [round(el) for el in circle_samples_y]
        # plt.plot(phi_linspace, circle_samples_x_round)
        # plt.plot(phi_linspace, circle_samples_y_round)
        circle_samples = zip(circle_samples_x_round, circle_samples_y_round)

        # if debug:
        #     circle_samples_list = [el for el in circle_samples]
        #     print(circle_samples_list)
        #     circle_samples = zip(circle_samples_x_round, circle_samples_y_round)

        # We'll use this to keep track of how much of the circle is actually
        # in the domain of the image
        for sample in circle_samples:
            sample_x = sample[0]
            sample_y = sample[1]
            if (sample_x < 0) or (sample_x >= image_domain[0]):
                continue
            if (sample_y < 0) or (sample_y >= image_domain[1]):
                continue
            num_valid_samples += 1
            integrand += image[sample_x, sample_y]

    # Ignore points that don't have enough valid samples
    if num_valid_samples < len(radii) * num_circle_samples // 2:
        cost = 0
    else:
        cost = integrand / num_valid_samples
    return -1 * cost


def cost2(params, image, debug):

    circle_center_x, circle_center_y, circle_radius = params

    half_width = 2
    num_diff_points = (2 * half_width) + 1
    diff_points_list = np.linspace(-half_width, half_width, num_diff_points)
    diff_points_list = [int(val) for val in diff_points_list]
    diffs = []
    for diff_x in diff_points_list:
        for diff_y in diff_points_list:
            if np.sqrt(diff_x ** 2 + diff_y ** 2) <= half_width:
                diffs.append((diff_x, diff_y))
    len_diffs = len(diffs)
    integrand = 0
    num_valid_samples = 0
    image_domain = image.shape

    circle_samples_x = circle_center_x + circle_radius * np.cos(phi_linspace)
    circle_samples_y = circle_center_y + circle_radius * np.sin(phi_linspace)
    circle_samples_x_round = [round(el) for el in circle_samples_x]
    circle_samples_y_round = [round(el) for el in circle_samples_y]
    # plt.plot(phi_linspace, circle_samples_x_round)
    # plt.plot(phi_linspace, circle_samples_y_round)
    circle_samples = zip(circle_samples_x_round, circle_samples_y_round)

    # if debug:
    #     circle_samples_list = [el for el in circle_samples]
    #     print(circle_samples_list)
    #     circle_samples = zip(circle_samples_x_round, circle_samples_y_round)

    # We'll use this to keep track of how much of the circle is actually
    # in the domain of the image
    for sample in circle_samples:

        sample_x = sample[0]
        sample_y = sample[1]

        # if (sample_x < half_width) or (
        #     sample_x >= image_domain[0] - half_width
        # ):
        #     continue
        # if (sample_y < half_width) or (
        #     sample_y >= image_domain[1] - half_width
        # ):
        #     continue
        num_valid_samples += 1

        sample_integrand = 0
        for el in diffs:
            diff_x, diff_y = el
            sample_integrand += image[sample_x + diff_x, sample_y + diff_y]
        # if sample_integrand / len_diffs > 1:
        if sample_integrand / len_diffs > 0.7:
            integrand += 1

    # Ignore points that don't have enough valid samples
    # if num_valid_samples < num_circle_samples // 2:
    #     cost = 0
    # else:
    #     cost = integrand / num_valid_samples
    cost = integrand / num_valid_samples
    return -1 * cost


# %% Main


def main(image_file_name, circle_a, circle_b, brute_range):

    cost_func = cost2
    optimize = True
    # optimize = False

    # Get the image as a 2D ndarray
    image_file_dict = tool_belt.get_raw_data(image_file_name)
    image = np.array(image_file_dict["readout_image_array"])
    image_domain = image.shape

    # Threshold
    thresh_image = np.array(image > 1.0, dtype=int)

    # Plot the image
    fig, ax = plt.subplots()
    fig.set_tight_layout(True)
    # img = ax.imshow(thresh_image, cmap="inferno")
    img = ax.imshow(image, cmap="inferno")
    _ = plt.colorbar(img)
    # return

    if optimize:

        # Set which image to optimize on
        opti_image = image
        # opti_image = thresh_image

        bounds_a = [(el - brute_range, el + brute_range) for el in circle_a]
        bounds_b = [(el - brute_range, el + brute_range) for el in circle_b]
        bounds_a = tuple(bounds_a)
        bounds_b = tuple(bounds_b)

        for bounds in [bounds_a, bounds_b]:

            # Start with a brute force optimization, then we'll do some fine tuning
            opti_circle = brute(cost_func, bounds, Ns=10, args=(image, False))
            # res = minimize(
            #     cost_func, x0=opti_circle, args=(opti_image, False), bounds=bounds
            # )
            # opti_circle = res.x

            print(opti_circle)
            print(cost_func(opti_circle, opti_image, True))

            # Plot the circle
            circle_patch = Circle(
                (opti_circle[1], opti_circle[0]),
                opti_circle[2],
                fill=False,
                color="w",
            )
            ax.add_patch(circle_patch)

    else:

        # Fig. 3
        # circle_a = [41.5, 36.5, 27.75]
        # circle_b = [40, 44, 27.75]
        # Fig. 4
        circle_a = [51, 46.5, 26]
        circle_b = [51.5, 56, 27]
        for opti_circle in [circle_a, circle_b]:
            # print(opti_circle)
            # print(cost(opti_circle, opti_image, True))

            # Plot the circle
            circle_patch = Circle(
                (opti_circle[1], opti_circle[0]),
                opti_circle[2],
                fill=False,
                color="w",
            )
            ax.add_patch(circle_patch)


# %% Run the file


if __name__ == "__main__":

    tool_belt.init_matplotlib()

    # # Fig. 3
    # image_file_name = "2021_09_30-13_18_47-johnson-dnv7_2021_09_23"
    # # circle_a = [41, 37.5, 28]
    # # circle_b = [40.5, 41.5, 29.5]
    # # Best circles by hand
    # circle_a = [41.5, 36.5, 27.75]
    # circle_b = [40, 44, 27.75]
    # brute_range = 2.5

    # Fig. 4
    image_file_name = "2021_10_17-19_02_22-johnson-dnv5_2021_09_23"
    circle_a = [51, 46.5, 26]
    circle_b = [51.5, 56, 27]
    brute_range = 2.5

    main(image_file_name, circle_a, circle_b, brute_range)

    plt.show(block=True)
