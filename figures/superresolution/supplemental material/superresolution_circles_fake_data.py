# -*- coding: utf-8 -*-
"""
Created on Fri Jun 24 09:47:46 2022

@author: ishi1

Code for generating/simulating muktiple NV cluster to test the circle fitting
routine by Matt and how to see how robust SAM is for NV clusters with our code
"""


import numpy as np
import matplotlib.pyplot as plt
from pathlib import Path

# from pathlib import PurePath
import json
import random

import utils.tool_belt as tool_belt
import superresolution_circles_full_auto as circle_fitting

# import math

filenm = "2022_01_03-08_49_15-johnson-nv0_2021_12_22"
data = tool_belt.get_raw_data(filenm)
dataz = data["readout_image_array"]
# print(readout_image_array)
img_range = data["img_range_2D"][0]
num_steps = data["num_steps_a"]  # we need this- number of x, y pixels
nv_sig = data["nv_sig"]
coords = nv_sig["coords"]
dataset = np.array(dataz)
dataset1 = np.array(dataz)

##################################

"""
Making new matrix by first adding columns and then rows:
-make new matrix by adding colums in front, then add columns at back
-then add rows (with new column numbers) at the top, and then bottom
(totalrows, totalcols) The total number of rows/columns being added is fixed
(row_front) Row added in front will be generated by a random number generator
(row_back) Row added at back determined by subtracting from total rows
(noise_l, noise_h) the range of background noise, eg 1 to 7
- Generate the base matrix with new extended axis (fake_data) by
first adding columns on both sides and then rows with increased column number
"""


# Generating a random column and append to end of matrix using append
def addcole(columns_added, num_row, noise_l, noise_h, dataset):
    newcol = np.empty(shape=(num_row, 1))
    for i in range(columns_added):
        for j in range(num_row):
            newcol[j][0] = float(random.randrange(noise_l, noise_h) / 10)
            # print( newcol[j][0])
        dataset = np.append(dataset, newcol, axis=1)
    return dataset


# Generating a random column and add to front of matrix using insert
# Note: Even though we are adding a column, for insert we need a row array
def addcolf(columns_added, num_row, noise_l, noise_h, dataset):
    newrow = np.empty(shape=(1, num_row))
    for i in range(columns_added):
        for j in range(num_row):
            newrow[0][j] = float(random.randrange(noise_l, noise_h) / 10)
            # print(newrow[0][j])
        dataset = np.insert(dataset, 0, newrow, axis=1)
    return dataset


# Generating a random row and add to front of matrix using insert
def addrowt(rows_added, num_column, noise_l, noise_h, dataset):
    newrow = np.empty(shape=(1, num_column))
    for i in range(rows_added):
        for j in range(num_column):
            newrow[0][j] = float(random.randrange(noise_l, noise_h) / 10)
            # print(newrow[0][j])
        dataset = np.insert(dataset, 0, newrow, axis=0)
    return dataset


# Generating a random row, add to matrix front using append
def addrowe(rows_added, num_column, noise_l, noise_h, dataset):
    newrow = np.empty(shape=(1, num_column))
    for i in range(rows_added):
        for j in range(num_column):
            newrow[0][j] = float(random.randrange(noise_l, noise_h) / 10)
            # print(newrow[0][j])
        dataset = np.append(dataset, newrow, axis=0)
    return dataset


def new_matrix(
    col_front,
    totalcols,
    row_front,
    totalrows,
    num_row,
    num_col,
    noise_l,
    noise_h,
    dataset,
):
    col_back = totalcols - col_front
    row_back = totalrows - row_front
    addedcolf = addcolf(col_front, num_row, noise_l, noise_h, dataset)
    addedcole = addcole(col_back, num_row, noise_l, noise_h, addedcolf)
    new_col_num = num_col + totalcols
    addedrowt = addrowt(row_front, new_col_num, noise_l, noise_h, addedcole)
    addedrowe = addrowe(row_back, new_col_num, noise_l, noise_h, addedrowt)
    final_matrix = addedrowe
    return final_matrix


def main():

    ##################################
    # IMPUT PARAMTERS HERE
    # --------------------

    totalrows = 30  # total number of pixels being added in the y axis
    totalcols = 30  # total number of pixels being added in the x axis
    num_col = (
        num_steps  # number of pxls added in x axis (columns) in the front
    )
    num_row = (
        num_steps  # # pxl being added in y axis(rows) at the top of matrix
    )
    noise_l = int(1 * 10)  # low range of background noise
    noise_h = int(6 * 10)  # upper limit of background noise
    noise_th = 6  # int(noise_h/10)
    # noise_th = int((noise_l+noise_h)/2)
    numof_matrix = 3  # number of matrices being added aka number of NV centers

    ##################################
    # Array with just the NV ring

    pixels = num_steps
    half_px = int(pixels / 2)
    px_up = 54  # (math.sqrt((half_px - 54)**2 + (half_px-30)**2))
    px_low = 40  # 1.1#half_px - 20
    new_arrpx = dataset1
    arrpx = dataset1
    for i in range((pixels)):
        for j in range(pixels):
            new_arrpx[i, j] = np.where(
                (half_px - i) ** 2 + (half_px - j) ** 2 <= px_up ** 2
                and (half_px - i) ** 2 + ((half_px - j) ** 2) >= px_low ** 2,
                arrpx[i, j],
                float(random.randrange(noise_l, noise_h) / 10),
            )
            # xx = math.sqrt((half_px - i)**2 + (half_px - j)**2)

    #####################################

    shifts = np.zeros(
        shape=(numof_matrix, 2)
    )  # list x&y px shift wrt centr coord
    randgen = np.zeros(
        shape=(numof_matrix, 2)
    )  # list x&y shifts generated random
    fake_data = new_matrix(
        int(totalcols / 2),
        totalcols,
        int(totalrows / 2),
        totalrows,
        num_row,
        num_col,
        noise_l,
        noise_h,
        dataset,
    )
    fake_data2 = new_matrix(
        int(totalcols / 2),
        totalcols,
        int(totalrows / 2),
        totalrows,
        num_row,
        num_col,
        noise_l,
        noise_h,
        dataset,
    )

    for i in range(numof_matrix):
        col_front = random.randrange(0, totalcols)
        row_front = random.randrange(0, totalrows)
        shifts[i][0] = col_front - int(totalcols / 2)
        shifts[i][1] = row_front - int(totalrows / 2)
        randgen[i][0] = col_front
        randgen[i][1] = row_front
        # print(col_front, row_front)
        newmatrix = new_matrix(
            col_front,
            totalcols,
            row_front,
            totalrows,
            num_row,
            num_col,
            noise_l,
            noise_h,
            new_arrpx,
        )
        fake_data = np.where(
            newmatrix < noise_th,
            np.add(fake_data, 0),
            np.add(fake_data, newmatrix),
        )  # if true, then 2nd arg
        # newmatrix2 = new_matrix(col_front, totalcols, row_front, totalrows,
        #                         num_row, num_col, noise_l, noise_h, dataset)
        # fake_data2 = np.where(newmatrix2 < noise_th, np.add(fake_data2, 0),
        #                       np.add(fake_data2, newmatrix2))

    # print(test)
    # print('fake data:')
    # print(fake_data)
    # print("number of pixels shifted in x,y=")
    # print(shifts)
    # print(randgen)

    # Plotting the New Matrices
    fig, ax = plt.subplots()
    img = ax.imshow(fake_data, cmap="inferno")
    clb = plt.colorbar(img)
    fig.tight_layout()

    timestamp = "-".join(filenm.split("-")[0:2])
    file_path_faked = tool_belt.get_file_path(
        __file__, timestamp, nv_sig["name"] + "-faked"
    )
    tool_belt.save_figure(fig, file_path_faked)

    fit_circles, fig = circle_fitting.main(image=dataset, run_type="full_auto")
    file_path = tool_belt.get_file_path(
        __file__, timestamp, nv_sig["name"] + "-orig_fit"
    )
    tool_belt.save_figure(fig, file_path)
    original_fit_circle = fit_circles[0]
    randgen_with_zero = randgen.tolist()
    randgen_with_zero.insert(0, [int(totalcols / 2), int(totalrows / 2)])
    orig_y, orig_x = original_fit_circle[0:2]
    circle_centers = [
        (orig_y + el[1], orig_x + el[0]) for el in randgen_with_zero
    ]

    # """
    # PLotting original data
    x_coord = coords[0]
    y_coord = coords[1]
    half_range = img_range / 2
    x_high = x_coord + half_range
    x_low = x_coord - half_range
    y_high = y_coord + half_range
    y_low = y_coord - half_range
    x = np.linspace(x_high, x_low, num_steps)
    half_pix = (x[1] - x[2]) / 2
    img_extent = [
        x_high + abs(half_pix),
        x_low - abs(half_pix),
        y_low - abs(half_pix),
        y_high + abs(half_pix),
    ]
    extent = tuple(img_extent)
    fig, ax = plt.subplots()
    img = ax.imshow(dataset, extent=extent, cmap="inferno")
    clb = plt.colorbar(img)
    fig.tight_layout()

    file_path_orig = tool_belt.get_file_path(
        __file__, timestamp, nv_sig["name"] + "-orig"
    )
    tool_belt.save_figure(fig, file_path_orig)

    raw_data = {
        "readout_image_array": fake_data.tolist(),
        "original_fit_circle": original_fit_circle.tolist(),
        "circle_centers": circle_centers,
    }
    tool_belt.save_raw_data(raw_data, file_path_faked)

    return fake_data


##################################################

if __name__ == "__main__":

    main()

    plt.show(block=True)

"""
# To test code
test = np.array([[0.0, 1, 2, 0, 1, 2], [1, 2, 3, 4, 5, 6],
                    [21, 22, 23, 24, 25, 26]])
totalrows = 4
totalcols = 4
num_col = 6
num_row = 3
noise_l = 10
noise_h = 60
numof_matrix = 2

avg_noise = int((noise_h-noise_l)/2)
newmatrix = new_matrix(2, totalcols, 2, totalrows, num_row, num_col, noise_l, noise_h, test)
shifts = np.zeros(shape=(numof_matrix, 2))
print(newmatrix)
for i in range(numof_matrix):
    col_front = 2#random.randrange(0, totalcols)
    row_front = 2#random.randrange(0, totalrows)
    shifts[i][0] = col_front
    shifts[i][1] = row_front
    # print(col_front, row_front)
    test2 = new_matrix(col_front, totalcols, row_front, totalrows,
                       num_row, num_col, noise_l, noise_h, test)
    print(test2)
    newmatrix = np.where(test2<3, np.add(newmatrix,0), np.add(newmatrix,test2))
    # if test2.any() < avg_noise == True:
    #     newmatrix += test2
    # newmatrix[test2[] > avg_noise] = newmatrix + test2
    # newmatrix = np.add(newmatrix, test2, where = []>avg_noise)
# print(test)
# print(test2)
print(newmatrix)
print(shifts)
"""
